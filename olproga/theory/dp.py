"""def solve(a, b):
    if b == 0:
        return 1
    if b % 2 == 0:
        return (solve(a, b // 2) ** 2) % (10 ** 9 + 7)
    return (solve(a, b - 1) * a) % (10 ** 9 + 7)


a, b = map(int, input().split())
print(solve(a, b))"""


# Из книги Олимп. программирование (Антти Лааксонен)

# Задача на дп:
"""
Есть множество номиналов монет c = {c1. c2, c3....ck} и денежная сумма n.
Нужно разменять сумму n используя как можно меньше монет.
"""

# Первое что приходит в голову: Действовать жадно, то есть брать монеты с самым большим номиналом.
# Однако, это не будет работать.
# Рассмотрим пример:

# c = {1, 3, 4}, n = 6 <- Это контрпример
# Наш алгоритм будет давать 3, когда можно взять 2 монеты.

# - Почему же?

# Алгорим выберет 4 + 1 + 1 = 6, но это не будет правдой. Правильный ответ:
# 3 + 3 = 6

# Значит наш жадник не корректен!

# - А как будет корректно?

# С помощью динамического программирования. Сначала мы придумаем рекурсивный подход.
# Нужно придумать задачу поменьше, которая решает точно также как и большую.

# solve(10) = solve(7) + 1 = solve(4) + 2 = solve(0) + 3 = 3

# Теперь можно представить общую рекурсивную функцию.

#            INF                          x < 0
# solve(x) = 0                            x = 0
#            min(best, solve(x - c) + 1)  x > 0

# Код:

n = int(input())
coins = list(map(int, input().split()))


def solve(n):
    if n < 0:
        return float('inf')
    if n == 0:
        return 0
    best = float('inf')
    for c in coins:
        best = min(best, solve(n - c) + 1)
    return best

print(solve(n))

# Функция неэффективна так как проверяет каждый способ размена. Но это можно исправить.

# !!!
# ЗАПОМИНАНИЕ. Запоминание это ключевая идея динамического программирования,
# то есть мы сохраняем каждое значение функции в массиве сразу после вычисления.
# И если впоследствии это значение понадобится снова, то мы достаем его из массива,
# не делая рекурсивных вызовов. Для этого создадим два массива:

N = 1e1000 # Эта константа выбрана так, чтобы все необходимые значения умещались в массив

ready = [False] * N # bool
val = [0] * N # int

# где ready[x] - признак, показывающий, было ли вычислено значение solve(x), а value[x] - само значение,
# если оно было вычислено. 

def solve(n):
    if n < 0:
        return float('inf')
    if n == 0:
        return 0
    if ready[n]:
        return val[n]
    best = float('inf')
    for c in coins:
        best = min(best, solve(n - c) + 1)
    ready[n] = True
    val[n] = best
    return best

# Эффективность этой функции объясняется тем, что значение для каждого параметра
# x рекурсивно вычисляется только один раз. А после того как значение solve(x) сохранено в
# value[x], его можно легко получить, когда функция снова будет вызвана с параметром x.
# Временная сложность O(nk), где n - подлежащая размену сумма, а k - кол-во номиналов.


# ИТЕРАТИВНАЯ РЕАЛИЗАЦИЯ.
# Отметим, что массив value можно также заполнить итеративно, воспользававшись следующим циклом:

val[0] = 0
for x in range(1, n + 1):
    val[x] = float('INF')
    for c in coins:
        if x - c >= 0:
            val[x] = min(val[x], val[x -c] + 1)

# На самом деле участники олимпиад предпочитают именно такую реализацию. (Она короче и постоянные множители меньше)
# Тем не менее рассуждать о дп часто проще в терминах рекурсивных функций.


# ПОСТРОЕНИЕ РЕШЕНИЯ.
# Иногда нас просят не только найти значение в оптимальном решении, но и привести пример
# построения самого решения. Чтобы сделать это для задачи о размене монет, объявим новый массив,
# в котором для каждой размениваемой суммы будем хранить первую монету в оптимальном решении:

first = [0] * N

val[0] = 0
for x in range(1, n + 1):
    val[x] = float('INF')
    for c in coins:
        if x - c >= 0 and (val[x - c] + 1 < val[x]):
            val[x] = val[x -c] + 1
            first[x] = c

while n > 0:
    print(first[n])
    n -= first[n]


# ПОДСЧЕТ РЕШЕНИЙ.
# Рассмотрим теперь другой вариант этой же задачи:
# требуется найти, сколькими способами можно разменять сумму x монетами заданных номиналов.

# И эту задачу можно решить рекурсивно. Обозначим solve(x) число способов разменять сумму x.
# Например, если coins = {1, 3, 4}, то solve(5) = 6, и рекурсивная формула имеет вид:

# solve(x) = solve(x - 1) + solve(x - 3) + solve(x - 4)

# А в общем виде рекурсивная функция выглядит так:

#            0                          x < 0
# solve(x) = 1                          x = 0
#            sum c ∊ coins solve(x - c) x > 0

count = [0] * N

count[0] = 0
for x in range(1, n + 1):
    for c in coins:
        if x - c >= 0:
            count[x] += count[x - c]