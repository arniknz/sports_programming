# ROUND: https://codeforces.com/contest/1829/


# A
"""p = list('codeforces')
for _ in range(int(input())):
    s = list(input())
    cnt = 0
    for i in range(len(s)):
        if s[i] != p[i]:
            cnt += 1
    print(cnt)"""


# B
"""for _ in range(int(input())):
    n = int(input())
    a = list(map(int, input().split()))
    zeros = 0
    cnt = 0
    for i in range(n):
        if a[i] == 0:
            cnt += 1
        else:
            cnt = 0
        zeros = max(zeros, cnt)
    print(zeros)"""


# C
"""for _ in range(int(input())):
    n = int(input())
    d = {}
    for _ in range(n):
        m, s = map(str, input().split())
        m = int(m)
        if s != '00':
            if s not in d:
                d[s] = m
            else:
                d[s] = min(d[s], m)
    if '11' in d and '10' in d and '01' in d:
        print(min(d['11'], d['10'] + d['01']))
    else:
        if '11' in d:
            print(d['11'])
        elif '01' in d and '10' in d:
            print(d['01'] + d['10'])
        else:
            print(-1)"""


# D
"""def solve(n, m):
    if n == m:
        return True
    if n % 3 != 0:
        return False
    return solve((n//3), m) or solve(((2 * n)//3), m)


for _ in range(int(input())):
    n, m = map(int, input().split())
    r = solve(n, m)
    if r:
        print('YES')
    else:
        print('NO')"""

"""
Эту задачу можно решить рекурсивно. Пусть в текущей куче n золотых самородков.

Если n = m, то мы можем составить кучку ровно из m золотых самородков, не выполняя никаких операций.

Если n не кратно 3, то сделать ход невозможно, потому что после хода мы разделяем n на x и 2x,
поэтому n = x + 2x = 3x для некоторого целого числа x, а значит, n должно быть кратно 3.

Наконец, если n кратно 3, то мы можем разделить кучку на две кучку по n//3 и 2n//3 золотых самородков и рекурсивно проверить,
можем ли мы составить кучку ровно из m золотых самородков.


Согласно Основной теореме, временная сложность составляет O(nlog32) ≈ O(n0.631).
Большинство компиляторов и языков программирования оптимизируют рекурсию достаточно, чтобы это прошло без проблем. 
(Решение модели на языке C++ выполняется за 15 миллисекунд.)
"""


# E
# Для этого нужен DFS (Стоит попрактиковаться порешать задачи на дфс в контесте группы ИТМО)
"""
Мы можем решить эту задачу, используя поиск в глубину (DFS) или поиск в ширину (BFS) на заданной сетке.
Идея заключается в том, чтобы рассматривать каждую ячейку сетки как потенциальную начальную точку для озера и исследовать все ячейки, достижимые из неё,
двигаясь только вверх, вниз, влево или вправо, не заходя на ячейки с глубиной 0.
Если мы достигаем тупика или ячейки с глубиной 0, мы возвращаемся назад и пробуем двигаться в другом направлении.
В ходе этого исследования мы отслеживаем сумму глубин всех посещённых ячеек. Эта сумма даёт нам объём текущего озера.
После того, как мы исследовали все достижимые ячейки от начальной точки,
мы сравниваем объём этого озера с максимально найденным объёмом и при необходимости обновляем максимум.
Для реализации этого подхода мы можем использовать вложенный цикл для перебора всех ячеек сетки.
Для каждой ячейки мы проверяем, больше ли её глубина 0, и не была ли она посещена ранее в каком-либо озере.
Если эти условия выполнены, мы начинаем DFS/BFS с этой ячейки и обновляем максимальный найденный объём.

Подробнее см. реализацию.

Сложность по времени — O(mn)
."""